var fs = require("fs-extra");
var path = require("path");
var readlineSync = require("readline-sync");
var commons = require("@vimlet/commons");
var Sync = require("sync");

var packageTemplate = require("./../resources/package-template");

var cwd = process.cwd();

exports.init = function () {

    console.log("");

    var packagePath = path.join(cwd, "package.json");

    var structure = -1;

    if (fs.pathExistsSync(packagePath)) {

        shouldAddAlpha();

    } else {
        structure = shouldDefaultStructure();
        shouldPackageJson(structure);
    }

    shouldGitignore(structure);
    shouldTestExample(structure);

    console.log("");

};


function addAlphaToPackageObject(packageObject) {

    // Add devDependencies
    if (!packageObject.devDependencies) {
        packageObject.devDependencies = {};
    }

    // Detect alpha project version
    packageObject.devDependencies["@vimlet/alpha"] = getAlphaVersion();

    // Add scripts
    if (!packageObject.scripts) {
        packageObject.scripts = {};
    }

    packageObject.scripts["format:js"] = "alpha format-js";
    packageObject.scripts["format:html"] = "alpha format-html";
    packageObject.scripts["format:css"] = "alpha format-css";
    packageObject.scripts.format = "run-s format:js format:html format:css";
    packageObject.scripts.test = "alpha test";
    packageObject.scripts["doc:api"] = "alpha doc api -i **/*.js,**/*.html -o ../docs/api";
    packageObject.scripts["doc:article"] = "alpha doc article -i ../docs/md/**/*.md -o ../docs/article";
    packageObject.scripts.doc = "run-s doc:api doc:article"
    packageObject.scripts.badges = "alpha badges -o badges";

}


function shouldAddAlpha() {

    defaultYes(readlineSync.question("The directory contains a package.json, add alpha? [yes|no] (yes) "), function () {


        var packagePath = path.join(cwd, "package.json");


        if (fs.existsSync(packagePath)) {

            // Read package file
            var packageFile = fs.readFileSync(packagePath);
            var packageObject = JSON.parse(packageFile.toString());

            addAlphaToPackageObject(packageObject);

            // Write modified file
            fs.writeFileSync(packagePath, JSON.stringify(packageObject, null, 2));

        }



    });

}

function shouldTestExample(option) {

    defaultYes(readlineSync.question("\nCreate test example? [yes|no] (yes) "), function () {

        fs.copySync(path.join(__dirname, "../resources/tests-template"), path.join(cwd, "tests"));
        // Note .gitignore files turn into .npmignore when published so they cant be copied
        fs.writeFileSync(path.join(cwd, "tests/.gitignore"), "/report.xml");

    });

}

function shouldPackageJson(option) {

    defaultYes(readlineSync.question("\nCreate package.json? [yes|no] (yes) "), function () {

        // Handle package name
        var projectName = toHyphenCase(path.basename(cwd));

        var askedName = readlineSync.question("  Package name? (" + projectName + ") ").trim();
        if (askedName != "") {
            projectName = askedName.toLowerCase();
        }

        var packageObject = packageTemplate.generate(projectName);

        addAlphaToPackageObject(packageObject);

        // No structure
        if (option == -1) {
            fs.writeFileSync(path.join(cwd, "package.json"), JSON.stringify(packageObject, null, 2));
            installAlpha(cwd);
        } else if (option == 1) {

            // Client/Server
            fs.writeFileSync(path.join(cwd, "src/client/package.json"), JSON.stringify(packageObject, null, 2));
            fs.writeFileSync(path.join(cwd, "src/server/package.json"), JSON.stringify(packageObject, null, 2));

            Sync(function () {
                installAlpha.sync(null, path.join(cwd, "src/client"));
                installAlpha.sync(null, path.join(cwd, "src/server"));
            });
        } else {
            // Module & Others
            fs.writeFileSync(path.join(cwd, "src/package.json"), JSON.stringify(packageObject, null, 2));
            installAlpha(path.join(cwd, "src"));
        }

    });

}

function shouldGitignore(option) {

    defaultYes(readlineSync.question("\nCreate .gitignore? This will override existing ones [yes|no] (yes) "), function () {

        // File .gitignore
        var gitignore = "";
        gitignore += "/node_modules\n";
        gitignore += "/npm-debug.log\n";

        // No structure
        if (option == -1) {

            fs.writeFileSync(path.join(cwd, ".gitignore"), gitignore);

        } else if (option == 1) {
            // Client/Server

            // // Add .gitignore
            fs.writeFileSync(path.join(cwd, "src/client/.gitignore"), gitignore);
            fs.writeFileSync(path.join(cwd, "src/server/.gitignore"), gitignore);

        } else {
            // Module & Others

            fs.writeFileSync(path.join(cwd, "src/.gitignore"), gitignore);
        }

    });

}

function shouldDefaultStructure() {

    var option = defaultZero(readlineSync.keyInSelect(["Module", "Webapp", "Other"], "Create project structure?", {
        guide: false,
        cancel: false
    }), function (index) {

        // Make basic dirs
        fs.mkdirsSync(path.join(cwd, "src"));
        fs.mkdirsSync(path.join(cwd, "tests"));
        fs.mkdirsSync(path.join(cwd, "docs"));

        if (index == 1) {
            // Client/Server

            // Make webapp dirs
            fs.mkdirsSync(path.join(cwd, "src/client"));
            fs.mkdirsSync(path.join(cwd, "src/server"));
            fs.mkdirsSync(path.join(cwd, "tests/client"));
            fs.mkdirsSync(path.join(cwd, "tests/server"));
            fs.mkdirsSync(path.join(cwd, "docs/client"));
            fs.mkdirsSync(path.join(cwd, "docs/server"));
        }

    });

    return option;

}


function getAlphaVersion() {

    var alphaPath = path.join(__dirname, "../../alpha");

    if (!fs.pathExistsSync(alphaPath)) {
        // Must be dev-mode symlink
        alphaPath = path.join(__dirname, "../../src");
    }

    var alphaPackage = fs.readFileSync(path.join(alphaPath, "package.json")).toString();

    return JSON.parse(alphaPackage).version;

}

function installAlpha(packagePath, cb) {
    console.log("\nInstalling vimlet-alpha package...\n");

    var alphaPath = path.join(__dirname, "../../alpha");

    if (!fs.pathExistsSync(alphaPath)) {
        // Must be dev-mode symlink
        alphaPath = path.join(__dirname, "../../src");
    }

    // Copy method
    //fs.copySync(alphaPath, path.join(packagePath, "node_modules/vimlet-alpha"));

    // Npm method
    commons.run.exec("npm", ["install", alphaPath, "--no-save"], packagePath, null, cb)
}

function defaultZero(i, cb) {
    if (i > -1) {
        cb(i);
    }
    return i;
}

function defaultYes(s, cb) {
    if (s.trim() == "" || s.toLowerCase().startsWith("y")) {
        cb();
    }
}

function defaultNo(s, cb) {
    if (s.toLowerCase().startsWith("y")) {
        cb();
    }
}

function toHyphenCase(s) {
    return s.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}