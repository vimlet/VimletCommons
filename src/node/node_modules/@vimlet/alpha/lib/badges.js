var path = require("path");
var fs = require("fs-extra");
var badge = require("gh-badges");
var program = require("commander");
var Sync = require("sync");

var cwd = process.cwd();

var badgesFile;
var badgesDir;
var badgeStyle = "flat";

/*
@function create
@description Creates badges
@param {object} args [Badges arguments]
@param {object} cb [Badges callback]
*/
exports.create = function (args, cb) {
  
    program
        .option("-i, --input <item>")
        .option("-o, --output <item>")
        .option("-r, --readme")
        .parse(args);


    badgesFile = program.input || path.join(cwd, "badges.json");
    badgesDir = program.output || "";
    readmeFile = program.readme || path.join(cwd, "README.md");

    if (fs.existsSync(badgesFile)) {

        // Make sure ouput dir exists
        fs.mkdirsSync(path.join(cwd, badgesDir));

        // Paint badges
        var badgesObject = JSON.parse(fs.readFileSync(badgesFile).toString());
        var aux;

        Sync(function () {

            Object.keys(badgesObject).forEach(function (key) {

                aux = badgesObject[key];
                createBadge.sync(null, key, aux.value, aux.color);

            });

            // Trigger callback
            if (cb) {

                cb(null, badgesObject);
            }

        });

        handleReadme(readmeFile, badgesObject, badgesDir);


    } else {
        // Trigger callback
        if (cb) {
            cb("No input file found.")
        }
    }



};

/*
@function createBadge
@description Creates badges 
@param {string} name [Badge name]
@param {string} value [Badge value]
@param {string} color [Badge color]
@param {object} cb [Callback]
*/
function createBadge(name, value, color, cb) {
    var fileName = name.toLowerCase().replace(new RegExp(" ", "g"), "-") + ".svg";

    badge({ text: [name, value], colorscheme: color, template: badgeStyle }, function (svg, err) {
        if (!err) {
            fs.writeFileSync(path.join(cwd, badgesDir, fileName), svg);
        }
        if (cb) {
            cb(err, svg)
        }
    });

}

/*
@function handleReadme
@description Checks if readme life exist and sets the badges text
@param {string} filePath [Readme file path]
@param {object} badgesObject [Contains badges information]
@param {string} badgesDir [Badges directory]
*/
function handleReadme(filePath, badgesObject, badgesDir) {
    var newReadText = "[//]: # (badges)\n\n";
    var capitalize;

    var badgesDir = badgesDir == "" ? badgesDir : badgesDir + "/"; 
    
    // Generates the code of badges for the readme file
    Object.keys(badgesObject).forEach(function (key) {

        capitalizeKey = key.replace(/\b\w/g, function(l){ return l.toUpperCase() });
        newReadText += '![' + key + '](' + badgesDir + key + '.svg?raw=true "' + capitalizeKey + '")\n';
        
    });

    newReadText += "\n[//]: # (badges)\n\n";

    // Sets the badges text into readme file
    if (fs.existsSync(filePath)) {
        var exp = new RegExp("\\[\\/\\/\\]: # \\(badges\\)[\\S\\s]*\\[\\/\\/\\]: # \\(badges\\)", "g");
        var fileText = fs.readFileSync(filePath).toString();
        var searchBadges = fileText.search(exp);

        (searchBadges > -1) ? fs.writeFileSync(readmeFile, fileText.replace(exp, newReadText)) : fs.writeFileSync(readmeFile, newReadText + fileText);
    
    // If readme file does not exist, created it and sets the badges text 
    } else {
        fs.writeFileSync(readmeFile, newReadText);
    }

}
