var program = require("commander");
var path = require("path");
var vimletMeta = require("@vimlet/meta");
var fileReader = require("./files-reader");
var fs = require("fs-extra");
var cwd = process.cwd();

//@property (private) {int} mdIndexFlagFiles @description Files amount of current generation to handle md index generation
var mdIndexFlagFiles = 0;

//@property (private) globalOutput [Current ouput will be used out of the init function scope]
var globalOutput;
//@property (private globalCallback [Current callback will be used out of the init function scope])
var globalCallback = null;

/*
@function (public) init [Generate doc files with its index]
@param argv {obj} [Comander process]
@param callback @optional
 */
exports.init = function(argv, callback) {
  program
    .version("1.0.0")
    .option("-i, --include <item, item...>", "Work folders", list)
    .option("-e, --exclude <items>", "Exclude sub folders", list)
    .option("-o, --output <item>", "Add output")
    .option("-c, --clean", "Empty directory before generate")
    .parse(process.argv);

  var include = program.include || [];
  if (!program.include) {
    include.push(path.join(cwd, "**/*.md"));
  }
  var exclude = program.exclude || [];
  var clean = program.clean || true;
  var output = program.output || path.join(cwd, "docs");

  globalOutput = output;
  globalCallback = callback;

  init(include, exclude, output, clean);
};

/*
@function init [Generate index from given files] (private)
@param include {[string]} [Array of patters to look for]
@param exclude {[string]} [Array of patterns to exclude]
@param include {[string]} [Array of patters to look for]
@param format {string} [Format of files to be indexed: "md"/"html"]
 */
function init(include, exclude, output, clean) {
  if (clean) {
    fileReader.deleteFolderRecursive(output);
  }
  copyFiles(include, exclude, output);
}

/*
@function copyFiles [Copy files from input to output/entries]
@param include {[string]} [Include patterns]
@param exclude {[string]} [Exclude patterns]
@param output {string}
 */
function copyFiles(include, exclude, output) {
  var fileOutput = path.join(output, "entries");
  mdIndexFlagFiles = 0;
  var filesInFolder = fileReader.getFiles(include, exclude);
  filesInFolder.forEach(function(files) {
    mdIndexFlagFiles += files.files.length;
    files.files.forEach(function(file) {
      if (path.extname(file) === ".md") {
        var tmpPath = path.join(files.root, file);
        var tmpOutput = path.join(fileOutput, file);
        var tmpFile = fs.readFileSync(tmpPath, "utf8");
        writeMdDoc(tmpFile, tmpOutput);
      } else {
        fs.copy(
          path.join(files.root, file),
          path.join(fileOutput, file),
          null,
          mdDocCreated
        );
      }
    });
  });
}

/*
@function getHTMLIndex (public) [Generate index while api html documentation.]
@param index {object} [object with files to index]
 */
exports.getHTMLIndex = function(index) {
  // Remove entries from output to place index.html in the output folder
  index.output = path.dirname(index.output);
  // Add entries to files url to find them while indexing
  var files = [];
  index.files.forEach(function(file) {
    file.url = path.join("entries", file.url);
    files.push(file);
  });
  index.files = files;
  getHTMLIndex(index);
};

/*
@function (private) initIndex [Generate index reading html files in given folders]
 */
function initIndex() {
  var indexInclude = [];
  indexInclude.push(path.join(globalOutput, "**/*.html"));
  var indexExclude = [];
  var filesInFolder = fileReader.getFiles(indexInclude, indexExclude);
  var index = {};
  index.files = [];
  index.output = path.resolve(globalOutput);
  filesInFolder.forEach(function(files) {
    files.files.forEach(function(file) {
      // Set current file index
      var currentIndex = {
        name: path.basename(file),
        extension: path.extname(file),
        //  url: file
        url: path.join(
          path.dirname(file),
          path.basename(file, path.extname(file))
        )
      };
      index.files.push(currentIndex);
    });
  });
  getHTMLIndex(index);
}

/*
@function getHTMLIndex (private) [Generate index from an index object]
@param index {object} [object with files to index]
 */
function getHTMLIndex(index) {
  var template = path.join(__dirname, "../templates/index.html.vim");
  vimletMeta.parse(template, path.join(index.output, "index.html"), index);
  var cssTemplate = path.join(__dirname, "../templates/index.css.vim");
  vimletMeta.parse(cssTemplate, path.join(index.output, "index.css"), index);
  if (globalCallback) {
    globalCallback();
  }
}

/*
@function writeMdDoc (private) [Write markdown file as html to disk]
@param data {object} [Markdown file to insert within html file]
@param output {string} [Result file path]
 */
function writeMdDoc(data, output) {
  htmlOutput = path.join(
    path.dirname(output),
    path.basename(output, ".md") + ".html"
  );
  var obj = {};
  obj.raw = data;
  var template = path.join(__dirname, "../templates/convertedMd.html.vim");
  vimletMeta.parse(template, htmlOutput, obj, mdDocCreated);
}

/*
@function mdDocCreated (private) [Callback when markdown is written as html]
 */
function mdDocCreated() {
  mdIndexFlagFiles--;
  if (mdIndexFlagFiles <= 0) {
    initIndex();
  }
}

/*
@function (private) list [Split a string into list. Used for commander]
@param val {string} [Value to split]
 */
function list(val) {
  return val.split(",");
}
