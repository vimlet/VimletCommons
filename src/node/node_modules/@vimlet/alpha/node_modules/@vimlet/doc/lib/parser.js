//@function parse {object} [Return file documentation as object] @param data {string} [File content] @param ext {string} [File extension]
exports.parse = function(data, ext) {
  return generate(data, ext);
};

//@property excludeStart (private) {string} [Exclude comments from here]
var excludeStart = "@exclude-start";
//@property excludeEnd (private) {string} [Exclude comments till here]
var excludeEnd = "@exclude-end";

//@property tagsObject (private) {object} [Tags and subtags]
var tagsObject = {
  "@header ": [],
  "@function ": {
    "@function ": ["@description "],
    "@method ": ["@description "],
    "@param ": ["@description ", "@optional"],
    "@param-optional ": ["@description "],
    "@return ": ["@description "],
    "@exception ": ["@description "]
  },
  "@method ": {
    "@function ": ["@description "],
    "@method ": ["@description "],
    "@param ": ["@description ", "@optional"],
    "@param-optional ": ["@description "],
    "@return ": ["@description "],
    "@exception ": ["@description "]
  },
  "@property ": ["@description "],
  "@attribute ": ["@description "]
};

//@property headerTag (private) {string}
var headerTag = "@header ";
//@property functionTag (private) {string}
var functionTag = "@function ";
//@property methodTag (private) {string}
var methodTag = "@method ";
//@property propertyTag (private) {string}
var propertyTag = "@property ";
//@property attributeTag (private) {string}
var attributeTag = "@attribute ";

//@property descriptionTag (private) {string}
var descriptionTag = "@description ";
//@property paramTag (private) {string}
var paramTag = "@param ";
//@property param_optionalTag (private) {string}
var param_optionalTag = "@param-optional ";
//@property returnTag (private) {string}
var returnTag = "@return ";
//@property exceptionTag (private) {string}
var exceptionTag = "@exception ";
//@property optionalTag (private) {string}
var optionalTag = "@optional ";

//@property globalPattern (private) {[object]} [Patterns to search for comments]
var globalPattern = [
  {
    open: "/*",
    close: "*/"
  },
  {
    open: "//",
    close: "\n" // TODO review close tag
  }
];

//@property rType (private) {object} [Shortag for type]
var rType = {
  open: "{",
  close: "}"
};
//@property rDescription (private) {object} [Shortag for description]
var rDescription = {
  open: "[",
  close: "]"
};
//@property rScope (private) {object} [Shortag for scope]
var rScope = {
  open: "(",
  close: ")"
};

/*
@function generate {object} [Generate documentation]
@param data {string} [File content]
@param ext {string} [File extension]
 */
function generate(data, ext) {
  var regexs = getRegex(ext);
  var matches = getMatches(data, regexs);
  var result = analyzeMatches(matches);
  return result;
}

/*
@function analyzeMatches {object} [Analyze tag matches]
@param matches {[string]}
 */
function analyzeMatches(matches) {
  var result = {};
  var header = [];
  var properties = [];
  var methods = [];
  matches.forEach(function(match) {
    analyzeMatch(match, header, properties, methods);
  });
  result.header = header;
  result.properties = properties;
  result.methods = methods;
  return result;
}

/*
@function analyzeMatch {object} [Analyze single match]
@param match {string}
@param header {[]} [Return header]
@param properties {[]} [Return properties]
@param methods {[]} [Return methods]
 */
function analyzeMatch(match, header, properties, methods) {
  match = match.substring(firstTag(match, tagsObject));
  var tagsMatches = splitTags(match, tagsObject);
  analyzeTags(tagsMatches, header, properties, methods);
}

/*
 @function analyzeTags {object} [Analyze all tags occurrences]
 @param tagsMatches {[string]}
 @param header {[]} [Return header]
 @param properties {[]} [Return properties]
 @param methods {[]} [Return methods]
  */
function analyzeTags(tagsMatches, header, properties, methods) {
  tagsMatches.forEach(function(tagMatch) {
    for (var tag in tagsObject) {
      if (tagMatch.indexOf(tag) != -1) {
        analyzeTag(tagMatch, tag, header, properties, methods);
      }
    }
  });
}

/*
 @function analyzeTag {object} [Analyze a single tag]
 @param str {string} [String with tag]
 @param tag {string} [Tag]
 @param header {[]} [Return header]
 @param properties {[]} [Return properties]
 @param methods {[]} [Return methods]
  */
function analyzeTag(str, tag, header, properties, methods) {
  switch (tag) {
    case headerTag:
      header.push(
        str
          .trim()
          .substring(tag.length)
          .trim()
      );
      break;
    case propertyTag:
      getProperty(str, tag, properties);
      break;
    case attributeTag:
      getProperty(str, tag, properties);
      break;
    case functionTag:
      getFunction(str, methods);
      break;
    case methodTag:
      getFunction(str, methods);
      break;
  }
  properties = sortByName(properties);
  methods = sortByName(methods);
}

/*
@function sortByName [Sort data by name] {[object]} @param data {[object]} [Data to sort]
 */
function sortByName(data) {
  data.sort(function(a, b) {
    var nameA = a.name.toLowerCase(),
      nameB = b.name.toLowerCase();
    if (nameA < nameB)
      //sort string ascending
      return -1;
    if (nameA > nameB) return 1;
    return 0;
  });
  return data;
}

/*
@function getProperty [Get properties from string with property tag]
@param str {string} [Property comment]
@param tag {string} [Property tag]
@param properties {[object]} [Output]
 */
function getProperty(str, tag, properties) {
  var result = {};
  str = str
    .trim()
    .substring(tag.length)
    .trim();
  splitNameType(str, result);
  properties.push(result);
}

/*
@function splitNameType [Split name, type and description from a string]
@param str {string} [String to split]
@param result {object} [Output]
 */
function splitNameType(str, result) {
  var lType = replaceSpecialTags(rType, str);
  if (lType) {
    str = str.replace(rType.regex, "").trim();
    result.type = lType;
  }

  if (str.indexOf(descriptionTag) > -1) {
    result.description = str
      .substring(str.indexOf(descriptionTag) + descriptionTag.length)
      .trim();
    str = str.substring(0, str.indexOf(descriptionTag));
  } else {
    var lDescription = replaceSpecialTags(rDescription, str);
    if (lDescription) {
      str = str.replace(rDescription.regex, "").trim();
      result.description = lDescription;
    }
  }

  var lScope = replaceSpecialTags(rScope, str);
  if (lScope) {
    str = str.replace(rScope.regex, "").trim();
    result.scope = lScope;
  }

  // First word after type must be the name
  result.name = firstWord(str).trim();
  str = str.substring(result.name.length).trim();
}

/*
@function replaceSpecialTags {string} [Replace shortcut tags]
@param cRegex {object} [Shortcut]
@param str {string} [String to replace shortcut]
 */
function replaceSpecialTags(cRegex, str) {
  var lMatch = str.match(cRegex.regex);
  if (lMatch) {
    lMatch = lMatch.toString();
    return clean(lMatch, cRegex);
  }
  return null;
}

/*
@function getFunction [Get functions from string with function tag]
@param str {string} [Function comment]
@param methods {[object]} [Output]
 */
function getFunction(str, methods) {
  var result = {};
  result.description = null;
  result.name = null;
  result.params = [];
  result.return = null;
  result.exceptions = [];
  var subTags = splitTags(str, tagsObject[functionTag]);
  var tReturn = null;
  var tFunction = null;
  subTags.forEach(function(subTag) {
    if (subTag.indexOf(returnTag) > -1) {
      var deeperTags = splitTags(subTag, tagsObject[functionTag][returnTag]);
      tReturn = subTag.substring(returnTag.length).trim();
    } else if (subTag.indexOf(functionTag) > -1) {
      tFunction = subTag.substring(functionTag.length).trim();
    } else if (subTag.indexOf(methodTag) > -1) {
      tFunction = subTag.substring(methodTag.length).trim();
    } else if (subTag.indexOf(paramTag) > -1) {
      var paramResult = {};
      if (subTag.indexOf(optionalTag) > -1) {
        paramResult.optional = true;
        subTag = subTag.replace(optionalTag, "").trim();
      }
      splitNameType(subTag.substring(paramTag.length).trim(), paramResult);
      result.params.push(paramResult);
    } else if (subTag.indexOf(param_optionalTag) > -1) {
      var param_optionalResult = {};
      param_optionalResult.optional = true;
      subTag = subTag.replace(optionalTag, "").trim();
      splitNameType(
        subTag.substring(param_optionalTag.length).trim(),
        param_optionalResult
      );
      result.params.push(param_optionalResult);
    } else if (subTag.indexOf(exceptionTag) > -1) {
      var exceptionResult = {};
      splitNameType(
        subTag.substring(exceptionTag.length).trim(),
        exceptionResult
      );
      result.exceptions.push(exceptionResult);
    }
  });
  checkShortTags(tReturn, tFunction, result);
  methods.push(result);
}

/*
@function checkShortTags [Chefk if a function has shortags and split them]
@param tReturn {string} [Function return if exists]
@param tFunction {string} [Function raw comment]
@param result {object} [Output]
 */
function checkShortTags(tReturn, tFunction, result) {
  var functionResult = {};
  splitNameType(tFunction, functionResult);
  result.name = functionResult.name;
  result.description = functionResult.description;
  if (functionResult.scope) {
    result.scope = functionResult.scope;
  }
  if (tReturn === null) {
    if (functionResult.type) {
      result.return = {};
      result.return.type = functionResult.type;
    }
  } else {
    var returnResult = {};
    splitNameType(tReturn, returnResult);
    result.return = {};
    result.return.type = returnResult.type;
    result.return.description = returnResult.description;
  }
}

/*
@function firstWord {string} [Return first workd of a string]
@param str {string}
 */
function firstWord(str) {
  str = str.trim();
  var empty = str.indexOf(" ");
  if (empty > -1) {
    return str.substring(0, empty);
  } else {
    return str.substring(0);
  }
}

/*
@function splitTags {[string]} [Split a comment in an array of tags]
@param str {string}
@param tagList {object} [Tags to search]
 */
function splitTags(str, tagList) {
  var tags = [];
  var nextTag = getNextTag(str, tagList);
  while (nextTag) {
    tags.push(nextTag);
    str = str.substring(nextTag.length);
    nextTag = getNextTag(str, tagList);
  }
  return tags;
}

/*
@function getNextTag {string} [Get a string from the first tag occurrence]
@param str {string}
@param tagList {object} [Tags to search]
 */
function getNextTag(str, tagList) {
  var first = firstTag(str, tagList);
  var nextTag = null;
  if (first > -1) {
    var second = firstTag(str.substring(first + 1), tagList) + 1;
    if (second > 0) {
      nextTag = str.substring(first, second);
    } else {
      nextTag = str.substring(first);
    }
  }
  return nextTag;
}

/*
@function firstTag {string} [Get first tag of a comment]
@param str {string}
@param tagList {object} [Tags to search]
 */
function firstTag(str, tagList) {
  var index = -1;
  if (!Array.isArray(tagList)) {
    for (var tag in tagList) {
      if (str.indexOf(tag) != -1) {
        if (str.indexOf(tag) < index || index === -1) {
          index = str.indexOf(tag);
        }
      }
    }
  } else {
    tagList.forEach(function(tagArray) {
      if (str.indexOf(tagArray) != -1) {
        if (str.indexOf(tagArray) < index || index === -1) {
          index = str.indexOf(tagArray);
        }
      }
    });
  }
  return index;
}

/*
@function getMatches [Get comment matches] {[string]}
@param data {string} [File data]
@param regexs {[object]} [Regexs used for get matches]
 */
function getMatches(data, regexs) {
  var matches = [];
  regexs.forEach(function(regex) {
    currentMatch = data.match(regex.regex);
    if (currentMatch) {
      currentMatch.forEach(function(cMatch) {
        cMatch = clean(cMatch, regex);
        matches.push(cMatch);
      });
    }
  });
  return matches;
}

/*
@function clean {string} [Remove regex tags from string]
@param match {string}
@param regex {object}
 */
function clean(match, regex) {
  regex.close = regex.close.replace(/(?:\r\n|\r|\n)/g, ""); // There is an issue where linebreak tag lenght should be 0
  match = match.replace(/(?:\r\n|\r|\n)/g, " "); // Replace line breaks with spaces. The result will fit a different area than in code
  match = match.trim();
  match = match
    .substring(regex.open.length, match.length - regex.close.length)
    .trim();
  match = match.replace(
    new RegExp(excludeStart + "([\\s\\S]*?)" + excludeEnd, "g"),
    ""
  ); // Remove exclude coments
  return match;
}

/*
@function getRegex {[object]} [Get regex for a given extension]
@param ext {string} [Extension to get regex] @optional
 */
function getRegex(ext) {
  //Fill fixed type and description regex
  rType.regex = new RegExp(
    escapeRegExp(rType.open) + "(?:[\\s\\S]*)" + escapeRegExp(rType.close),
    "g"
  );
  rDescription.regex = new RegExp(
    escapeRegExp(rDescription.open) +
      "(?:[\\s\\S]*)" +
      escapeRegExp(rDescription.close),
    "g"
  );
  rScope.regex = new RegExp(
    escapeRegExp(rScope.open) + "(?:[\\s\\S]*)" + escapeRegExp(rScope.close),
    "g"
  );

  var regexs = [];
  globalPattern.forEach(function(pattern) {
    var currentRegex = new RegExp(
      escapeRegExp(pattern.open) + "([\\s\\S]*?)" + escapeRegExp(pattern.close),
      "g"
    );
    var fullRegex = {
      open: pattern.open,
      close: pattern.close,
      regex: currentRegex
    };
    regexs.push(fullRegex);
  });
  return regexs;
}

/*
@function escapeRegExp {string} [Escape special regex characters]
@param str {string}
 */
escapeRegExp = function(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
};
