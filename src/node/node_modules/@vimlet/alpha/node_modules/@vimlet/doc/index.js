#!/usr/bin/env node

var program = require("commander");
var fs = require("fs-extra");
var path = require("path");
var vimletMeta = require("@vimlet/meta");
var Sync = require("sync");

// Import libraries
var parser = require("./lib/parser");
var fileReader = require("./lib/files-reader");
var docIndexer = require("./lib/doc-indexer");
//@property cwd [Working directory]
var cwd = process.cwd();

//@property defaultExclude {[string]} [node_modules folders are excluded by default if the user doesn't specify any exclude at all]
var defaultExclude = ["**/node_modules/**"];

//@property (private globalCallback [Current callback will be used out of the init function scope])
var globalCallback = null;

//@property (private) filesToWrite [Trigger to launch callback when all files are created]
var filesToWrite = 0;

/*
@function (public) toMarkdown @description Generate documentation as markdown.
@param include {[string]} @description Folders included for documentation
@param exclude {[string]} @description Folders excluded from documentation
@param output {string} @description Destination folder
@param clean {boolean} @description Folders included for documentation @optional
@param callback @optional
 */
exports.toMarkdown = function(include, output, exclude, clean, callback) {
  globalCallback = callback;
  clean = clean || true;
  if (clean) {
    fileReader.deleteFolderRecursive(output);
  }
  var filesToDoc = fileReader.getFiles(include, exclude);
  if (filesToDoc.length > 0) {
    var filesDoc = generateDoc(filesToDoc);
    if (!isEmpty(filesDoc.files)) {
      callMDGenerator(filesDoc, output);
    } else {
      console.log("No files matching the criteria");
    }
  }
};

/*
@function (public) toHTML @description Generate documentation as HTML.
@param include {[string]} @description Folders included for documentation
@param exclude {[string]} @description Folders excluded from documentation
@param output {string} @description Destination folder
@param clean {boolean} @description Folders included for documentation @optional
@param callback @optional
 */
exports.toHTML = function(include, output, exclude, clean, callback) {
  globalCallback = callback;
  clean = clean || true;
  if (clean) {
    fileReader.deleteFolderRecursive(output);
  }
  var filesToDoc = fileReader.getFiles(include, exclude);
  if (filesToDoc.length > 0) {
    var filesDoc = generateDoc(filesToDoc);
    if (!isEmpty(filesDoc.files)) {
      callHTMLGenerator(filesDoc, output, include);
    } else {
      console.log("No files matching the criteria");
    }
  }
};

// Command mode
if (!module.parent) {
  var value;
  var found;
  var instruction = false;
  for (var index = 0; index < process.argv.length && !found; index++) {
    value = process.argv[index].toLocaleLowerCase();
    switch (value) {
      case "article":
        found = true;
        instruction = true;
        docIndexer.init(process.argv);
        break;
      case "api":
        found = true;
        instruction = true;
        init(process.argv);
        break;
    }
  }

  if (!instruction) {
    console.log("");
    console.log("Unknown command.");
    console.log("Use:");
    console.log(" vimlet-doc api --help");
    console.log(" vimlet-doc article --help");
    console.log("");
  }
}

/*
  @funciton (private) init [Generate documentation. Called from comand]
  @param argv
  @param callback @optional
   */
function init(argv, callback) {
  program
    .version("1.0.0")
    .option("-i, --include <item, item...>", "Work folders", list)
    .option("-e, --exclude <items>", "Exclude sub folders", list)
    .option("-o, --output <item>", "Add output")
    .option("-f, --format <item>", "Extension to work with")
    .option("-c, --clean", "Empty directory before generate")
    //   .on('--help', function() {
    //   console.log('  Examples:');
    //   console.log();
    //   console.log();
    // });
    .parse(process.argv);

  // console.log("program.help1",program.help);
  //
  // program.parse(process.argv);
  //
  // program.help();
  //
  //   console.log("program.help2",program.help);

  var include = program.include || [
    path.join(cwd, "**/*.js"),
    path.join(cwd, "**/*.html")
  ];
  var output = program.output || path.join(cwd, "docs");
  var exclude = program.exclude || defaultExclude;
  var extension = program.format || "html";
  switch (extension) {
    case "html":
      exports.toHTML(include, output, exclude, program.clean);
      break;
    case "md":
      exports.toMarkdown(include, output, exclude, program.clean);
      break;
    default:
      console.log("Format doesn't match");
      break;
  }
}

/*
  @function generateDoc (private) [Generate doc object for each single file]
  @param files {array} [Aim files]
   */
function generateDoc(files) {
  var result = {};
  var absolute = path.resolve("./");
  var resultFiles = {};
  result.basePath = absolute;
  files.forEach(function(file) {
    var filesArray = file.files;
    filesArray.forEach(function(f) {
      var currentDoc;
      if (!fileReader.isDirectory(f)) {
        currentDoc = parser.parse(
          fs.readFileSync(path.join(file.root, f), "utf8"),
          path.extname(f),
          true
        );
      }
      if (currentDoc) {
        currentDoc.path = f;
        resultFiles[f] = currentDoc;
      }
    });
  });
  result.files = resultFiles;
  return result;
}

/*
  @function (private) list [Split a string into list. Used for commander]
  @param val {string} [Value to split]
   */
function list(val) {
  return val.split(",");
}

/*
  @function (private) callHTMLGenerator [Generate html files from template]
  @param filesDoc {object}
  @param folder {string} [Root folder]
   */
function callHTMLGenerator(filesDoc, folder) {
  // Index all files for html index
  var index = {};
  index.files = [];
  folder = path.join(folder, "entries");
  index.output = path.resolve(folder);
  var files = filesDoc.files;
  filesToWrite = 0;
  for (var file in files) {
    filesToWrite++;
    var fileName = path.basename(file, path.extname(file)) + ".html";
    var dirRelative = path.dirname(file);
    var dir = path.join(folder, dirRelative);
    var abs = path.join(dir, fileName);

    var template = path.join(__dirname, "templates/main.html.vim");

    if (
      files[file].header.length > 0 ||
      files[file].properties.length > 0 ||
      files[file].methods.length > 0
    ) {
      // Set current file index
      var currentIndex = {
        name: path.basename(file),
        extension: path.extname(file),
        url: path.join(
          dirRelative,
          path.basename(fileName, path.extname(fileName))
        )
      };
      index.files.push(currentIndex);
      vimletMeta.parse(template, abs, files[file], generatorCallback);
    } else {
      console.log("No documentation found for:", abs);
    }
    getHTMLcss(dir);
  }
  docIndexer.getHTMLIndex(index);
}

/*
  @function generatorCallback (private) [Callback when a doc is written to disk]
   */
function generatorCallback() {
  filesToWrite--;
  if (filesToWrite <= 0) {
    if (globalCallback) {
      globalCallback();
    }
  }
}

/*
  @function (private) callMDGenerator [Generate markdown files from template]
  @param filesDoc {object}
  @param folder {string} [Root folder]
   */
function callMDGenerator(filesDoc, folder) {
  // Index all files for html index
  var index = {};
  index.files = [];
  index.output = path.resolve(folder);
  var files = filesDoc.files;
  filesToWrite = 0;
  for (var file in files) {
    filesToWrite++;
    var fileName = path.basename(file, path.extname(file)) + ".md";
    var dirRelative = path.dirname(file);
    var dir = path.join(folder, dirRelative);
    var abs = path.join(dir, fileName);

    var template = path.join(__dirname, "templates/main.md.vim");

    if (
      files[file].header.length > 0 ||
      files[file].properties.length > 0 ||
      files[file].methods.length > 0
    ) {
      // Set current file index
      var currentIndex = {
        name: path.basename(file),
        url: path.join(dirRelative, fileName)
      };
      index.files.push(currentIndex);

      vimletMeta.parse(template, abs, files[file], generatorCallback);
    }
  }
}

/*
  @function getHTMLcss (private) [Generate css for html documentation]
  @param dir {string} [Folder to place css]
   */
function getHTMLcss(dir) {
  var cssTemplate = path.join(__dirname, "templates/style.css.vim");
  var cssAbs = path.join(dir, "style.css");
  vimletMeta.parse(cssTemplate, cssAbs, null);
}

/*
  @function isEmpty {boolean} [Check is an object is empty]
  @param myObject {object}
   */
function isEmpty(myObject) {
  for (var key in myObject) {
    if (myObject.hasOwnProperty(key)) {
      return false;
    }
  }

  return true;
}
